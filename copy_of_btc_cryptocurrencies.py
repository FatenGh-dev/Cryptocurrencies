# -*- coding: utf-8 -*-
"""Copy of BTC-cryptocurrencies

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iZdwcUtYeF4HFezMXZOThKvnKUcqikLp
"""

import io
import pandas as pd
from google.colab import files
uploaded = files.upload()

import tensorflow as tf
import tensorboard as tb
import pandas as pd
# Importing  csv files

data = pd.read_csv('BTC.csv')
# Dataset is now stored in a Pandas Dataframe

data

data = data.drop(['Date','Market','price_usd','total_supply','circulating_supply'], axis = 1)
len(data)

import numpy as np
import pandas as pd
import random
import time
from collections import deque
from sklearn import preprocessing
from tensorflow import *
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.datasets import load_iris
import numpy as np
from keras.preprocessing import sequence
from keras.models import Sequential
from keras.layers import Dense, Dropout, Embedding, LSTM, Bidirectional
from keras.datasets import imdb 
from tensorflow.keras import Sequential
from tensorflow.keras.layers import Dense, LSTM, Dropout

from sklearn.preprocessing import MinMaxScaler
#transform feature into ranges
scaler = MinMaxScaler()
#the maximum of encoded integer  
n_unique_words = 100000 
#number of words 200 words
batch_size = 128

(x_train, y_train),(x_test, y_test) = imdb.load_data(num_words=n_unique_words)
#x_train transform a list to 2d 
##maxlen=maximum size
x_train = sequence.pad_sequences(x_train, maxlen=None)
x_test = sequence.pad_sequences(x_test, maxlen=None)
#CREATE AN ARRAY NP.ARRAY(matrice)
y_train = np.array(y_train)
y_test = np.array(y_test) 
#Reshaping x_test  to  change the shape of an array.
x_test = np.reshape(x_test, (x_test.shape[0],
                            x_test.shape[1], 
                                          1))

print(x_test.shape)

from keras.layers import LSTM, Dense, Bidirectional, Input,Dropout,BatchNormalization, CuDNNGRU, CuDNNLSTM
#Sequential class is designed to build the nn
model = Sequential()
#model.add(Embedding(n_unique_words, 128, input_length=maxlen))####
## initialize the first layer LSTM layer we will use 
##units= 45 : the number of lstm we will use
#return sequences = true because we will use another lstm
#input_shape :  is the number of timespteps , we are using 200 timesteps but  we have only 1 predicor
model.add(LSTM(units = 45, return_sequences = True, input_shape = (x_test.shape[1], 1)))
#dropout is used to avoid overfitting while training
#we should dropout 20 % of the layer 
model.add(Dropout(0.2))

model.add(Bidirectional(LSTM(32)))
model.add(Dropout(0.5))
#the unit is 1 and the function that we will apply  is sigmoid 
#the unit is 1 and the function that we will apply  is sigmoid ,the sigmoid will transform the values between 1/0 to filter the more/less important information

model.add(Dense(1,activation='sigmoid'))
##adam optimizer is useful in a wide variety of neural network
## the cross-entropy loss between true labels and predicted labels.
##accuracy = precision 
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
print(model.summary())

model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

import tensorflow as tf
import datetime

from keras.callbacks import TensorBoard

# Load the TensorBoard notebook extension
tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir="./logs")

#epochs = is the number of iterations
#the training data is x_train+y_train
#batch size depends on how we will train the data in this case we need the faster so we
history=model.fit(x_train, y_train,batch_size=64,epochs=3,validation_data=[x_test, y_test], callbacks=[tensorboard_callback])

# Commented out IPython magic to ensure Python compatibility.
#   %reload_ext tensorboard
tensorboard

# Commented out IPython magic to ensure Python compatibility.

# Load the TensorBoard notebook extension
# %load_ext tensorboard
tensorboard = TensorBoard(log_dir="logs/{}")
tensorboard
# %tensorboard --logdir logs/fit

tf.keras.utils.plot_model(model, to_file='model.png', show_shapes=True, show_layer_names=False)

import matplotlib.pyplot as plt


loss = history.history['loss']
val_loss = history.history['val_loss']
epochs = range(len(loss))
plt.figure()
plt.plot(epochs, loss, 'b', label='Training loss')
plt.plot(epochs, val_loss, 'r', label='Validation loss')
plt.title("Training and Validation Loss")
plt.legend()
plt.show()

pd.set_option('display.max_columns', 8)
pd.set_option('display.width', 1000)
uploaded = files.upload()

data = pd.read_csv('BTC.csv')

print(data.head())
print('')
print(data.shape) 
print('')

data['Date'] = pd.to_datetime(data['Date']).dt.date
group = data.groupby('Date')
#there is date+marketcap 
Real_Price = group['market_cap_usd'].mean()
print(group.head())
print('') 

# we have 61 rows and 13 columns
print(Real_Price.head())
print('') 
print(Real_Price.shape)  
print('')
#shape of real price is 61 the rows

prediction_days = 60

df_train = Real_Price[:len(Real_Price) - prediction_days]
df_test = Real_Price[len(Real_Price) - prediction_days:]
##read head of df_train 
print(df_train.head())
print('')
##shape df_train
print(df_train.shape)
print('')
##read head of test
print(df_test.head())
print('')
##shape df_test

print(df_test.shape)
print('')

training_set = df_train.values 
training_set = np.reshape(training_set, (len(training_set),1))

print("Training set after reshaping:")
print('')
print(training_set)
print('')
print(training_set.shape)
print('')

#transform feature into ranges MinMaxScaler

sc = MinMaxScaler() 
training_set = sc.fit_transform(training_set) 
X_train = training_set[0 : len(training_set) -1]
y_train = training_set[1 : len(training_set)]
X_train = np.reshape(X_train, (len(X_train),1, 1)) 
                       
print("Scaled training set:")
print('')
print(training_set)
print('')
print("Define X_train")
print('')
print(X_train)
print('')
print(X_train.shape)
print("Define y_train:")
print('')
print(y_train)
print('')
print(y_train.shape)
print('')
print("X_train reshaped:")
print('')
print(X_train) 
print('') 
print(X_train.shape)
print('')

### define the RNN model 
### instantiate the RNN model object 
regr = Sequential() 

### add the input and LSTM layers 
regr.add(LSTM(units =4, activation ='sigmoid', input_shape =(None, 1)))    

### add the output layer
regr.add(Dense(units =1))

### compile the RNN 
regr.compile(optimizer = 'adam', loss = 'mean_squared_error', metrics = ['accuracy']) 

### fit the model on the training set 
regr.fit(X_train, y_train, batch_size =5, epochs =150)  

### log the keras model with mlflow 
with mlflow.start_run() as run:
  mlflow.keras.log_model(regr, "Bitcoin Price Prediction")

regr.compile(optimizer = 'adam', loss = 'mean_squared_error', metrics = ['accuracy'] ,run_eagerly=True) 

### fit the model on the training set 
regr.fit(X_train,y_train, batch_size =32, epochs =10)

### create predictions on the test set 
##repeat the same work like the training = test
#read df_test values the shape the different values 
test_set = df_test.values
inputs = np.reshape(test_set, (len(test_set), 1)) 
#transform is used for testing
inputs = sc.transform(inputs)
inputs = np.reshape(inputs, (len(inputs), 1, 1))
##use the model that we worked on , then predict different data then transform feature into ranges using sc

predicted_BTC_price = regr.predict(inputs) 
predicted_BTC_price = sc.inverse_transform(predicted_BTC_price)

print("Test set after reshaping:")
print('')
print(inputs)
print('')
print(inputs.shape)
print('')
print("Scaled inputs:")
print('')
print(inputs) 
print('')
print("Reshaped inputs:")
print('')
print(inputs)
print('')
print(inputs.shape)
print('')
print("Predicted BTC price: ", predicted_BTC_price)
print('')
print("Scaled predicted BTC price: ", predicted_BTC_price)
print('')

### get evaluation of the model predictions 
model_evaluation = regr.evaluate(inputs, predicted_BTC_price) 

print("Model evaluation is: ", model_evaluation)  
print('')

### visualize the results 
print("Visualize the results:") 
print('')

### plot the actual and predicted prices 
plt.figure(figsize =(25, 15), dpi =100, facecolor ='w', edgecolor ='k')
ax = plt.gca() 
plt.plot(test_set, color = 'red', label = "Real BTC Price") 
plt.plot(predicted_BTC_price, color = 'blue', label = "Predicted BTC Price") 
plt.title("BTC Price Prediction", fontsize = 40)

### reindex the 'df_test' dataframe 
df_test = df_test.reset_index() 
x = df_test.index

### set labels
labels = df_test['Date']

### set xticks 
plt.xticks(x, labels, rotation = 'vertical')

### set fontsize for 'x' and 'y' ticks 
for tick in ax.xaxis.get_major_ticks():
    tick.label1.set_fontsize(18)

for tick in ax.yaxis.get_major_ticks():
    tick.label1.set_fontsize(18)
    
### set plot labels 
plt.xlabel('Time', fontsize = 40)
plt.ylabel('BTC Price(USD)', fontsize = 40)

### set plot legend
plt.legend(loc = 2, prop = {'size' : 25})  

### show the plot 
plt.show()



